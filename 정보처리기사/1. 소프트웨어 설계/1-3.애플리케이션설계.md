# 1. 소프트웨어 아키텍처
> - 소프트웨어의 골격이 되는 기본 구조 + 구성 요소 간의 관계를 표현하는 시스템의 구조(구조체)
> - 소프트웨어 개발 시 적용되는 원칙과 지침 ➡️ 이해관계자들의 의사소통 도구
> - 좋은 품질 유지하면서 기능적 요구사항으로 나타난 제약 반영, 구현하는 방법을 찾는 해결과정
> - 애플리케이션 분할 방법, 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정

## 가. 기본원리 
### 1) 모듈화(Modularity)
> - 성능 향상, 시스템의 수정 및 재사용, 유지관리의 용이를 위해서 시스템의 기능들을 모듈 단위로 나누는 것
#### 가) 모듈
> - 모듈화를 통해 분리된 시스템의 각 기능들(= 서브시스템, 작업단위, 소프트웨어 내 프로그램 등)
> - 단독으로 컴파일이 가능하고 재사용할 수 있어야 함

##### A. 모듈의 기능적 독립성 
>   - 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨 ➡️ 하나의 모듈은 하나의 기능만을 수행(다른 모듈과의 과도한 상호작용은 배제)
>   - 독립성이 높을수록 수정하더라도 다른 모듈에 영향이 적거나 없음
>   - 독립성이 높은 모듈 = 약한 결합도 + 강한 응집도

##### B. 결합도 
> - 모듈 간 상호의존하는 정도 또는 두 모듈 사이의 연관관계
> - 결합도가 약할수록 품질이 높음
> - 결합도가 강할수록 구현 및 유지보수가 어려워짐
> - 종류
>   - 자료 결합도(1) : 모듈 간 인터페이스가 자료 요소로만 구현될 때의 결합도
>       - 매개변수로 데이터를 넘겨주면 데이터에 대한 처리결과만 돌려받는 방식
>       - 서로의 내용을 전혀 알 필요가 없음 ➡️ 한 모듈의 내용을 변경하더라도 다른 모듈에는 전혀 영향을 끼치지 않음
>       - 가장 바람직함
>   - 스탬프(검인)결합도(2) : 모듈 간 인터페이스가 배열이나 레코드 등의 자료구조가 전달될 때의 결합도
>       - 두 모듈이 동일한 자료구조를 조회하는 경우의 결합도
>       - 자료구조의 변화는 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈에도 영향을 미침
>   - 제어 결합도(3) : 다른 모듈 내부의 논리적인 흐름을 제어하기 위해서 제어신호를 이용해 통신, 제어요소를 전달하는 결합도
>       - 한 모듈이 다른 모듈의 처리 절차를 상세하게 알고 이를 통제하는 경우
>       - 처리 기능이 두 모듈에 분리되어 설계된 경우
>       - 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상 발생
>   - 외부 결합도(4) : 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도
>       - 참조되는 데이터의 범위를 각 모듈에서 제한할 수 있음
>   - 공통(공유) 결합도(5) : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도 
>       - 공통 데이터 영역의 내용을 조금만 변경해도 이를 사용하는 모든 모듈에 영향을 미침 ➡️ 독립성을 약하게 만듦
>   - 내용 결합도(6) : 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도 
>       - 한 모듈에서 다른 모듈의 내부로 제어가 이동하는 경우

##### C. 응집도 
> - 정보 은닉의 확장된 개념 ➡️ 모듈이 독립적인 기능으로 정의되어 있는 정도(= 같은 기능끼리 잘 모아서 모듈을 만들었는가)
> - 응집도가 강할수록 품질이 높음
> - 종류 
>   - 기능적 응집도(7) : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우 
>   - 순차적 응집도(6) : 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우
>   - 교환(통신)적 응집도(5) : 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우
>   - 절차적 응집도(4) : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우
>   - 시간적 응집도(3) : 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우
>   - 논리적 응집도(2) : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우
>   - 우연적 응집도(1) : 모듀 ㄹ내부의 각 구성 요소들이 서로 관련 없는 요소들로 구성된 경우

##### D. 팬인(Fan-In)/팬아웃(Fan-Out)
> - 팬인 : 어떤 모듈을 제어(호출)하는 모듈의 수
> - 팬아웃 : 어떤 모듈에 의해 제어(호출)되는 모듈의 수
> - 팬인과 팬아웃을 분석하면 ➡️ 시스템의 복잡도를 알 수 있음
> - 시스템의 복잡도 최적화 ➡️ 팬인은 높게, 팬아웃은 낮게<br>
> \* 팬인이 높음 : 재사용 측면에서는 설계가 잘됨. 하지만 단일 장애점이 발생할 수 있음
> \* 팬아웃이 높은 : 불필요하게 다른 모듈을 호출하고 있는지 확인할 필요가 있음

##### E. N-S차트(Nassi-Schneiderman Chart)
> - 논리의 기술에 중점을 둔 도형을 이용한 표현 방법으로 박스 다이어그램, Chapin Chart라고 함
> - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조 표현
> - GOTO나 화살표 사용 X
> - 조건 복합되어 있는 곳 처리를 시각적으로 명확히 식별하는데 적합
> - 선택과 반복 구조를 시각적으로 표현
> - 이해 쉽고, 코드 변환 용이
> - 읽기는 쉽지만 작성하기 어려움, 임의로 제어 전이 불가능
> - 총체적인 구조 표현과 인터페이스 표현 어려움
> - 단일 입구과 단일 출구로 표현

#### 나) 공통모듈
> - 여러 프로그램에서 공통적으로 사용할 수 있는 모듈(계산식, 사용자 인증 등)
> - 모듈의 재사용성 확보 및 중복 개발 회피 ➡️ 설계 과정에서 공통 부분 식별 후 명세 작성 필요
> - 공통 모듈 구현 시 다른 개발자들이 명확하게 기능을 알 수 있도록 명세기법을 준수해야 함
##### A. 명세 기법 
>   - 정확성
>   - 명확성 
>   - 완전성
>   - 일관성
>   - 추적성

##### B. 공통모듈의 재사용
> - 비용과 시간을 절약하기 위해 이미 개발된 기능들을 파악, 재구성하여 새로운 시스템, 기능 개발에 적합하도록 최적화시키는 작업
> - 누구나 이해할 수 있고 사용할 수 있도록 사용법 공개
> - 재사용 대상 모듈은 외부 모듈과의 결합도는 낮고 응집도는 높아야 함
> - 규모에 따른 분류
>   - 함수와 객체 : 클래스나 메소드 단위의 소스코드를 재사용
>   - 컴포넌트 : 컴포넌트 수정없이 인터페이스를 통해 통신하는 방식으로 재사용
>   - 애플리케이션 : 공통된 기능을 제공하는 애플리케이션을 공유하는 방식으로 재사용

##### C. 효과적인 모듈 설계 방안
> - 결합도는 줄이고 응집도는 높임 ➡️ 독립성과 재사용성을 높임
> - 모듈의 제어 영역 안에서 그 모듈의 영향 영역을 유지
> - 복잡도와 중복성을 줄이고 일관성 유지
> - 모듈의 기능은 예측 가능해야 함
> - 유지보수가 용이해야 함
> - 하나의 입구와 하나의 출구
> - 효과적인 제어를 위해 모듈 간 계층적 관계를 정의하는 자료를 제시해야 함

### 2) 추상화(Abstraction)
> - 전체적, 포괄적인 개념 설계 후 차례로 세분화하여 구체화 시켜나가느 ㄴ것
> - 인간이 복잡한 문제를 해결할 때 사용하는 가장 기본적인 방법
> - 최소의 비용으로 실제 상황에 대처 가능, 시스템 구조 및 구성을 대략적으로 파악 가능
#### 가) 유형
> - 과정 추상화 : 전반적인 흐름만 파악할 수 있게 설계하는 방법(자세한 수행과정 X)
> - 데이터 추상화 : 데이터 구조를 대표할 수 있는 표현으로 대처하는 방법(데이터의 세부 속성, 용도 정의 X)
> - 제어 추상화 : 이벤트 발생 정확한 절차, 방법을 정의하지 않고 대표할 수 있는 표현으로 대체하는 방법

#### 나) 단계적 분해(Stepwise Refinement)
> - 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화 시키는 분할 기법으로 하향식 설계전략(Niklaus Wirth)
> - 추상화의 반복을 통해 세분화

### 3) 정보 은닉(Information Hiding)
> - 한 모듈 내부에 포함된 절차와 자료들의 정부가 감추어져 있어 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
> - 커뮤니케이션이 필요할 경우 필요한 정보만 인터페이스를 통해 주고 받음
> - 모듈의 독립성 보장
> - 모듈의 수정, 시험, 유지보수에 용이(독립성 보장 ➡️ 하나의 모듈이 변경되더라도 다른 모듈에 영향X)

## 나. 품질 속성
> - 소프트웨어 아키텍처가 이해 관계자들의 요구에 맞는 수준의 품질을 보장할 수 있도록 설계되었는지를 확인하기 위해 품질 평가 요소들을 구분하여 구체화 시켜놓은 것
### 1) 시스템 측면
> - 성능
> - 보안
> - 가용성
> - 기능성
> - 사용성
> - 변경 용이성
> - 확장성
> - 기타 속성 : 테스트 용이성, 배치성, 안정성 등

### 2) 비지니스 측면
> - 시장 적시성
> - 비용과 혜택
> - 예상 시스템 수명
> - 기타 속성 : 목표 시장, 공개 일정, 기존 시스템과의 통합 등

### 3) 아키텍처 측면
> - 개념적 무결성
> - 정확성, 완결성
> - 구축 가능성
> - 기타 속성 : 변경성, 시험성, 적응성, 일치성 등

## 다. 설계 과정
### 1) 설계 목표 설정
> - 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비지니스 목표, 우선 순위 등 요구사항을 분석, 전체 시스템의 설계 목표를 설정

### 2) 시스템 타입 결정
> - 시스템과 서브시스템 타입 결정, 설계 목표를 고려하여 아키텍처 패턴 선택
#### 가) 시스템 타입
> - 대화형 시스템 : 사용가의 요구가 발생하면 시스템이 이를 처리하고 반응하는 시스템(대부분의 웹 애플리케이션)
> - 이벤트 중심 시스템 : 외부의 상태 변화에 따라 동작하는 시스템(전화, 비상벨 등 내장 소프트웨어)
> - 변환형 시스템 : 데이터가 입력되면 정해진 작업들을 수행, 결과 출력하는 시스템(컴파일러, 네트워크 프로토콜 등)
> - 객체 영속형 시스템 : 데이터베이스를 사용, 파일을 효과적으로 저장, 검색, 갱신할 수 있는 시스템(서버 관리 소프트웨어)

### 3) 아키텍처 패턴 적용
> - 아키텍처 패턴을 참조, 표준 아키텍처를 설계
> - 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴 등

### 4) 서브시스템 구체화 
> - 서브시스템의 기능 및 서브시스템 간 상호작용을 위한 동작, 인터페이스를 정의

### 5) 검토 
> - 아키텍처가 목표에 부합하는지, 요구사항 반영은 잘 되었는지, 설계의 기본원리는 만족하는지 등을 검토

# 2. 아키텍처 패턴(= 표준 아키텍처)
> - 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
> - 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시
> - 서브시스템과 그 역할이 정의되어 있고 서브시스템 간 관계와 규칙, 지침 등이 포함되어 있음

## 가) 장점
> - 시행착오를 줄여 개발 시간 단축, 고품질의 소프트웨어 생산 가능
> - 이미 검증된 구조 ➡️ 안정적인 개발 가능
> - 공통된 아키텍처 공유 ➡️ 의사소통이 간편
> - 시스템 구조의 이해 쉬움 ➡️ 유지 보수 용이
> - 시스템의 특성을 개발 전에 예측 가능

## 나) 종류
### 1) 레이어 패턴
> - 시스템을 계층으로 구분하여 구성
> - 각각의 서브시스템이 계층 구조를 이루며 상위 계층 : 서비스 제공자, 하위 계층 : 클라이언트가 됨
> - 서로 마주보는 두 계층 간에만 상호작용 가능 ➡️ 변경이 용이
> - 예) 네트워크 OSI 7계층(물리 - 데이터 링크 - 네트워크 - 전송 - 세션 - 표현 - 응용)<br>
![레이어패턴](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbdMmYB%2FbtqHA49i1xj%2FASHrFz0vftouBZWKzDjfM0%2Fimg.png) <br>
> 출처 : https://lipcoder.tistory.com/273

### 2) 클라이언트-서버 패턴
> - 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
> - 사용자는 클라이언트와만 의사소통 함 ➡️ 서버는 클라이언트의 요청에 대비해 항상 대기상태 유지
> - 클라이언트와 서버는 서로 독립적(요청, 응답을 위한 동기화 제외)<br>
![클라이언트서버패턴](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbyic7N%2FbtqHShFcEkj%2F4pAPZOzk2sMJ8FoWrwZ3kk%2Fimg.png) <br>
> 출처 : https://lipcoder.tistory.com/273

### 3) 파이프-필터 패턴
> - 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴
> - 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬움 ➡️ 확장이 용이
> - 필터 컴포넌트 재배치를 통해 다양한 파이프라인 구축이 가능
> - 필터 간 데이터 이동 시 데이터 변환으로 인한 오버헤드 발생 
> - 주로 데이터 변환, 버퍼링, 동기화에 사용
> - 예) UNIX - Shell <br>
![파이프필터패턴](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbbU1ZK%2FbtqHEewNvgZ%2FH49M3lPuImjo1yimYnddpK%2Fimg.png) <br>
> 출처 : https://lipcoder.tistory.com/273 

### 4) 모델-뷰-컨트롤러 패턴
> - 서브시스템을 3개의 부분으로 구조화 하는 패턴
> - 모델 : 서브시스템의 핵심기능, 데이터를 보관
> - 뷰 : 사용자에게 정보 표시
> - 컨트롤러 : 사용자로부터 받은 입력 처리
> - 각 부분은 별도의 컴포넌트로 구분 ➡️ 서로 영향을 받지 않고 개발 가능
> - 여러 개의 뷰를 만들 수 있음 ➡️ 대화형 애플리케이션에 적합
>   \* 대화형 애플리케이션 : 한 개의 모델에 여러 개의 뷰를 필요로 하는 애플리케이션(온라인 쇼핑몰 등)<br>
![모델뷰컨트롤러](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbhts9L%2FbtqHBSAPZpZ%2FmPmiSmk6NULRiuuwUkAWTK%2Fimg.png) <br>
> 출처 : https://lipcoder.tistory.com/273

### 5) 기타
##### 가) 마스터-슬레이브 패턴
> - 마스터 컴포넌트 : 모든 작업의 주체 
> - 슬레이트 컴포넌트 : 마스터 컴포넌트의 지시에 따라 작업을 수행, 결과 반환
> - 주로 장애 허용 시스템, 병렬 컴퓨팅 시스템에 주로 활용

##### 나) 브로커 패턴
> - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해 줌
> - 원격 서비스 호출에 응답하는 컴포넌트들이 여러 개 있을 때 적합
> - 분산 환경 시스템에 주로 활용

##### 다) 피어-투-피어 패턴
> - 피어를 하나의 컴포넌트로 간주 ➡️ 피어는 클라이언트가 될수도 서버가 될수도 있음
> - 클라이언트와 서버는 멀티스레딩 방식을 사용함
> - 토렌트(?)

##### 라) 이벤트-버스 패턴
> - 소스가 특정 채널에 이벤트 메시지를 발행(Publish) ➡️ 해당 채널을 구독식(Subscribe)한 리스너들이 메시지르르 받아 이벤트를 처리하는 방
> - 주요 컴포넌트 
>   - 소스 : 이벤트 생성
>   - 리스너 : 이벤트 수행
>   - 채널 : 이벤트의 통로
>   - 버스 : 채널 관리
> 
##### 마) 블랙보드 패턴
> - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태 <br> 
> ➡️ 컴포넌트들은 검색을 통해서 블랙보드에서 원하는 데이터를 찾을 수 있음
> - 해결책이 명확하지 않은 문제를 처리하는데 유리
> - 음성 인식, 차량 식별, 신호 해석 등에 주로 활용

##### 라) 인터프리터 패턴
> - 프로그램 코드의 라인들은 수행하는 방법을 지정, 기호마다 클래스를 갖도록 구성
> - 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용


# 3. 디자인 패턴
> - 각 모듈의 세분적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
> - 문제 및 배경, 실제 적용 사례, 재사용 가능한 샘플 코드 등으로 구성
> - 한 패턴을 변형하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화되는 특징
> - GoF(Gang Of Four)의 디자인 패턴 - 1995, 에릭 감마, 리차드 헬름, 랄프 존슨, 존 블리시디 <br>
> ➡️ 많은 디자인 패턴 중 일반적인 사례에 적용될 수 있는 패턴을 분류, 정리 ➡️ 현업에서 지금까지 가장 많이 사용되는 패턴

## 가. 아키텍처 패턴과 디자인 패턴 
> - 아키텍처 패턴이 디자인 패턴보다 상위 수준의 설계에서 사용됨
> - 아키텍처 패턴 : 시스템의 전체 구조 설계를 위한 참조 모델
> - 디자인 패턴 : 서브시스템에 속하는 몇몇 컴포넌트들과 그 관계를 설계하기 위한 참조 모델

## 나. 장단점 
### 1) 장점 
> - 범용적인 코딩 스타일 ➡️ 구조 파악에 용이
> - 객체 지향 설계 및 구현의 생산성을 높임
> - 검증된 구조의 재사용 ➡️ 개발 시간과 비용 절약
> - 개발자간 원활한 의사소통 가능
> - 설계 변경 요청에 유연한 대처 가능

### 2) 단점 
> - 초기 투자 비용의 부담
> - 객체 지향을 기반으로 하지 않는 애플리케이션의 설계와 구현에는 적합하지 않음

## 다. 종류
### 1) 생성 패턴
> - 객체 생성과 관련된 패턴
> - 객체의 생성, 참조과정을 캡슐화 ➡️ 객채 생성, 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 유연성을 더함
#### 가) 추상 팩토리(Abstract Factory)
> - 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 의존, 연관되는 객체들의 그룹으로 생성하여 추상적으로 표현
> - 연관된 서브 클래스를 한번에 교체하는 것이 가능

#### 나) 빌더(Builder)
> - 작게 분리된 인스턴스를 조합하여 객체 생성
> - 객체의 생성과정과 표현 방법의 분리

#### 다) 팩토리 메서드(Factory Method = 가상 생성자) 
> - 객체 생성을 서브 클래스에서 처리하도록 분리하도록 캡슐화한 패턴
> - 상위클래스에서는 인터페이스만 정의, 객체는 서브 클래스에서 생성

#### 라) 프로토타입(Prototype)
> - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴

#### 마) 싱글톤(Singleton)
> - 하나의 객체를 생성하면 어디서든 참조할 수 있음(여러 프로세스가 동시에 참조X)
> - 클래스 내에서 인스턴스가 하나임을 보장 ➡️ 불필요한 메모리 낭비 최소화

### 2) 구조 패턴
> - 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴
> - 구조가 복잡한 시스템을 개발하기 쉽게 도와줌
#### 가) 어댑터(Adapter)
> > - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
> - 기존 클래스를 이용하려 했는데 인터페이스가 일치하지 않을 때

#### 나) 브릿지(Bridge)
> - 구현부에서 추상화된 부분을 분리 ➡️ 서로 독립적으로 확장할 수 있도록 구성한 패턴
> - 기능과 구현을 두 개의 별도 클래스로 구현

#### 다) 컴포지트(Composite)
> - 여러 객체를 가진 복합 걕체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
> - 객체들을 트리 구조로 구성(복합 객체 안에 복합 객체가 포함되는 구조 표현 가능)
> - 디렉도리 안에 디렉토리가 있는 개념

#### 라) 데코레이터(Decorator)
> - 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
> - 임의의 객체에 부가적인 기능 추가를 위해 다른 객체들을 덧붙이는 방식

#### 마) 퍼싸드(Facade)
> - 복잡한 서브 클래스들을 피해 상위 인터페이스를 구성 ➡️ 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
> - 서브 클래스들 사이의 통합 인터페이스르 제공하는 Wrapper객체가 필요

#### 바) 플라이웨이트(Flyweight)
> - 인스턴스가 필요할 때마다 매번 생성하는 것이 아니라 가능한 공유하여 사용 ➡️ 메모리 절약하는 패턴
> - 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용

#### 사) 프록시(Proxy)
> - 접근이 어려운 객체와 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
> - 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 사용


### 3) 행위 패턴
> - 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴
> - 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분해 ➡️ 결합도를 최소화할 수 있음

#### 가) 책임 연쇄(Chain of Responsibility)
> - 요청을 처리할 수 있는 객체가 둘 이상 ➡️ 한 객체가 요청을 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
> - 요청을 처리할 수 있는 개체들끼리 Chain으로 묶여 있기 때문에 요청이 해결될 때까지 Chain을 따라 책임이 넘어감

#### 나) 커맨드(Command)
> - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
> - 요청에 사용되는 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화

#### 다) 인터프리터(Interpreter)
> - 언어에 문법 표현을 정의하는 패턴
> - SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용

#### 라) 반복자(Iterator)
> - 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
> - 내부 표현 방법의 노출 없이 순차적 접근 가능

#### 마) 중재자(Mediator)
> - 수많은 객체들 간 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
> - 객체 사이의 의존성을 줄임 ➡️ 결합도 감소
> - 중재자는 객체 간의 통제와 지시의 역할 수행

#### 바) 메멘토(Memento)
> - 특정 시점에서 객체 내부 상태를 객체화함 ➡️ 이후 요청에 따라 객체를 해당 시점의 상태로 되돌릴 수 있는 기능을 제공하는 패턴
> - cmd + z 

#### 사) 옵저버(Observer) 
> - 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
> - 분산 시스템 간 이벤트를 생성, 발생, 수신해야 할 때 사용

#### 아) 상태(State)
> - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
> - 객체 상태를 캡슐화하고 이를 참조하는 방식

#### 자) 전략(Strategy)
> - 동일한 계열의 알고리즘들을 개방적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
> - 클라이언트는 독립적으로 원하는 알고리즘을 선택해서 사용 가능
> - 클라이언트에 영향 없이 알고리즘의 변경 가능

#### 차) 템플릿 메서드(Template Method)
> - 상위 클래스에서 골격을 정의, 하위 클레스에서 세부 처리를 구체화하는 구조의 패턴
> - 유사한 서브 클래스들의 공통 내용을 묶어 상위 클래스를 정의 ➡️ 코드의 양을 줄이고 유지 보수를 용이하게 함

#### 카) 방문자(Visitor)
> - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
> - 분리된 처리 기능은 각 클래스를 방문하여 수행


# 4. 객체지향 
> - 하나의 제품을 만들 때 여러 개의 부품을 조립하여 만들 듯이 소프트웨어도 여러 객체들을 조립하여 개발하는 기법
> - 소프트웨어의 재사용 및 확장이 용이 ➡️ 고품질의 소프트웨어를 빠르게 개발 가능, 유지 보수가 쉬움
> - 복잡한 구조를 단계적, 계층적으로 표현
> - 멀티미디어 데이터 및 병렬 처리 지원

## 가. 주요 구성요소

### 1) 객체(Object)
> - 데이터와 함수를 묶어놓은(캡슐화한)하나의 소프트웨어 모듈
>   - 데이터 : 객체가 가지고 있는 정보(속성, 상태, 변수, 상수, 자료구조라고도 함)
>   - 함수 : 객체가 수행하고자 하는 기능 ➡️ 객체가 갖는 데이터를 처리하는 알고리즘
> - 객체의 특성 
>   - 객체는 독립적으로 식별 가능한 이름을 가짐
>   - 객체가 가질 수 있는 조건을 상태라고 하는데 일반적으로 상태는 시간에 따라 변함
>   - 객체와 객체는 상호 연관성에 의한 관계가 형성
>   - 객체는 일정한 저장소를 가지고 있음
> - 메서드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행함
> - 객체 지향 기법(프로그램 = 객체 + 객체(데이터 + 함수)) ↔️ 구조적 기법(프로그램 = 데이터 + 함수)

### 2) 클래스(Class)
> - 공통된 속성과 연산을 갖는 객체의 집합 ➡️ 객체의 일반적인 타입을 의미
> - 각각의 객체들이 갖는 속성과 연선을 정의하고 있는 틀
> - 데이터를 추상화하는 단위
> - 인스턴스 : 클래스에 속한 각각의 객체
>   - 인스턴스화 : 클래스로부터 실제 객체를 생성하는 것

## 나. 주요 개념
### 1) 캡슐화(Encapsulation)
> - 데이터(속성)와 함수를 하나로 묶는 것
> - 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 적음 <br>
> ➡️ 인터페이스를 제외한 정보가 은닉되어 외부에서의 접근이 제한적이기 때문
> - 캡슐화된 객체는 재사용이 용이하고
> - 객체 간 메시지를 주고 받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고 결합도는 낮아짐

### 2) 상속(Inheritance)
> - 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는 것
> - 상속 받은 하위 클래스는 상위 클래스의 모든 속성과 연산을 정의하지 않고도 자신의 속성으로 사용 가능
> - 상속 받은 속성과 연산 외 자신만의 속성, 연산을 추가하여 사용 가능
> - 소프트웨어의 재사용을 높이는 중요한 개념
> - 다중 상속 : 한 클래스가 2개 이상의 클래스를 상속 받는 것

### 3) 다형성(Polymorphism)
> - 객체가 연산을 수행할 때, 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
> - 객체들은 동일한 메서드 명을 사용하며 같은 의미의 응답을 함
> - 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스 처럼 수행할 수 있도록 하는 것

### 4) 연관성(Relationship)
> - 두 개 이상의 객체들이 상호 참조하는 관계

|종류|의미|특징|
|---|---|---|
|is member of|연관화(Association)|2개 이상의 객체가 상호 관련되어 있음을 의미|
|is instacne of|분류화(Classification)|동일한 형의 특성을 갖는 객체들을 모아 구성하는 것|
|is part of|(Aggregation)|관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것|
|is a|(Generation)|공통적인 성질들로 추상화한 상위 객체를 구성하는 것|
|is a|(Specialization)|상위 객체를 구체화하여 하위 객체를 구성하는 것|

# 5. 객체지향 분석(OOA : Object Oriented Analysis) 및 설계
> - 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 객체, 이와 연관된 속성, 연산, 그들 간의 관계 등을 정의하여 모델링하는 작업
> - 소프트웨어를 개발하기 위한 비지니스 업무를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석
> - 클래스, 객체, 속성, 연산들을 표현하여 문제를 모형화할 수 있게 해야 함
> - 객체는 클래스로부터 인스턴스화 되는데, 이 클래스를 식별하는 것이 객체지향 분석의 주요 목적

## 가. 객체지향 분석의 방법론
### 1) 럼바우(Rumbaugh) 방법
> - 가장 일반적으로 사용되는 방법으로 모든 소프트웨어 구성요소를 그래픽 표기법을 이용하여 모델링 하는 기법(=객체 모델링 기법(OMT : Object Modeling Technique))
#### 가) 분석활동의 순서 및 정의  
>  1. 객체 모델링(=정보 모델링) : 시스템에서 요구되는 개체를 찾아 속성과 연산 식별 및 객체 간 관계를 규정하여 객체 다이어그램으로 표시
>  2. 동적 모델링 : 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어, 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
>  3. 기능 모델링 : 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간 자료 흐름을 중심으로 처리 과정을 표현한 모델링

### 2) 부치(Booch) 방법
> - 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의 
### 3) 제이콥슨(Jacobson) 방법 
> - Use Case를 강조하여 사용하는 분석 방법
### 4) 코드(Coad)와 요든(Yourdon) 방법
> - E-R 다이어그램을 사용하여 객체의 행위를 모델링, 객체 식별, 구조 시별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법
### 5) 워프스-브록(Wirfs-Brock) 방법
> - 분석과 설계 간의 구분이 없음, 고객 명세서를 펑가하여 설계 작업까지 연속적으로 수행하는 기법

## 나. 객체지향 설계 원칙(SOLID 원칙)
> - 시스템의 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야할 5가지 원칙
### 1) 단일 책임 원칙(SRP : Single Responsibility Principle)
> - 하나의 객체는 하나의 책임만 가져야 함(응집도는 높게, 결합도는 낮게) 
### 2) 개방-폐쇄 원칙(OCP : Open-Closed Principle) 
> - 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 함(공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화)
### 3) 리스코프 치환 원칙(LSP : Liskov Substitution Principle)
> - 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙
### 4) 인터페이스 분리 원칙(ISP : Interface Segregation Principle)
> - 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
### 5) 의존 역전 원칙(DIP : Dependency Inversion Principle)
> - 각 객체들 간 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와의 의존 관계를 맺어야 함 

# 6. 코드
> - 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류, 조합 및 집계를 용이하게 하고 특정 자료의 추출을 쉽게 하기 위해 사용하는 기호 
> - 정보를 신속, 정확, 명료하게 전달할 수 있음
> - 일정한 규칙에 따라 작성 
> - 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미침
> - 예) 주민등록번호, 학번 등

## 가. 기능
### 1) 식별 기능
> - 데이터 간 성격에 따라 구분 가능 
### 2) 분류 기능
> - 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화
### 3) 배열 기능
> - 의미를 부여하거나 나열 가능
### 4) 표준화 기능
> - 다양한 데이터를 기준에 맞추워 표현 가능
### 5) 간소화 기능
> - 복잡한 데이터를 간소화 가능

## 나. 종류
### 1) 순차 코드(= 순서 코드, 일련번호 코드)
> - 자료의 발생 순서, 크키 순서 등 일정 기준에 따라 차례로 일련번호를 부여하는 방법
### 2) 블록 코드(= 구분 코드)
> - 공통성이 있는 것끼리 블록응로 구분, 각 블록 내에서 일련번호를 부여하는 방법
### 3) 10진 코드(= 도서 분류식 코드)
> - 코드화 대상을 0~9까지 10진 분할하고 다시 각각에 대해 10진 분할하는 방법을 반복
### 4) 그룹 분류 코드
> - 일정 기준에 따라 대분류, 중분류, 소분류등으로 구분하고 각 그룹 안에서 일련번호를 부여하는 방법
### 5) 연상 코드
> - 코드화 대상 항목의 명칭이나 약호와 관계 있는 수자나 문자, 기호를 이용하여 코드를 부여하는 방법 
### 6) 표의 숫자 코드(= 유효 숫자 코드)
> - 대상 항목의 성질(길이, 넓이, 부피, 지름, 높이 등)을 그대로 코드에 적용시키는 방버
### 7) 합성 코드
> - 2개 이상의 코드를 조합하여 만드는 방법

## 다. 코드 부여 체계
> - 이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식
> - 각 개체에 유일한 코드를 부여 ➡️ 개체들의 식별 및 추출 용이
> - 코드 부여 전 각 단위 시스템의 고유 코드와 개체를 나타내는 코드가 정의 되어야 함
> - 코드의 자릿수와 구분자, 구조등을 상세히 명시해야 함