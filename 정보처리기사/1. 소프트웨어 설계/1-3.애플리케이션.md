# 1. 소프트웨어 아키텍처
> - 소프트웨어의 골격이 되는 기본 구조 + 구성 요소 간의 관계를 표현하는 시스템의 구조(구조체)
> - 소프트웨어 개발 시 적용되는 원칙과 지침 ➡️ 이해관계자들의 의사소통 도구
> - 좋은 품질 유지하면서 기능적 요구사항으로 나타난 제약 반영, 구현하는 방법을 찾는 해결과정
> - 애플리케이션 분할 방법, 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정

## 가. 기본원리 
### 1) 모듈화(Modularity)
> - 성능 향상, 시스템의 수정 및 재사용, 유지관리의 용이를 위해서 시스템의 기능들을 모듈 단위로 나누는 것
#### 가) 모듈
> - 모듈화를 통해 분리된 시스템의 각 기능들(= 서브시스템, 작업단위, 소프트웨어 내 프로그램 등)
> - 단독으로 컴파일이 가능하고 재사용할 수 있어야 함

##### A. 모듈의 기능적 독립성 
>   - 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨 ➡️ 하나의 모듈은 하나의 기능만을 수행(다른 모듈과의 과도한 상호작용은 배제)
>   - 독립성이 높을수록 수정하더라도 다른 모듈에 영향이 적거나 없음
>   - 독립성이 높은 모듈 = 약한 결합도 + 강한 응집도

##### B. 결합도 
> - 모듈 간 상호의존하는 정도 또는 두 모듈 사이의 연관관계
> - 결합도가 약할수록 품질이 높음
> - 결합도가 강할수록 구현 및 유지보수가 어려워짐
> - 종류
>   - 자료 결합도(1) : 모듈 간 인터페이스가 자료 요소로만 구현될 때의 결합도
>       - 매개변수로 데이터를 넘겨주면 데이터에 대한 처리결과만 돌려받는 방식
>       - 서로의 내용을 전혀 알 필요가 없음 ➡️ 한 모듈의 내용을 변경하더라도 다른 모듈에는 전혀 영향을 끼치지 않음
>       - 가장 바람직함
>   - 스탬프(검인)결합도(2) : 모듈 간 인터페이스가 배열이나 레코드 등의 자료구조가 전달될 때의 결합도
>       - 두 모듈이 동일한 자료구조를 조회하는 경우의 결합도
>       - 자료구조의 변화는 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈에도 영향을 미침
>   - 제어 결합도(3) : 다른 모듈 내부의 논리적인 흐름을 제어하기 위해서 제어신호를 이용해 통신, 제어요소를 전달하는 결합도
>       - 한 모듈이 다른 모듈의 처리 절차를 상세하게 알고 이를 통제하는 경우
>       - 처리 기능이 두 모듈에 분리되어 설계된 경우
>       - 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상 발생
>   - 외부 결합도(4) : 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도
>       - 참조되는 데이터의 범위를 각 모듈에서 제한할 수 있음
>   - 공통(공유) 결합도(5) : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도 
>       - 공통 데이터 영역의 내용을 조금만 변경해도 이를 사용하는 모든 모듈에 영향을 미침 ➡️ 독립성을 약하게 만듦
>   - 내용 결합도(6) : 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도 
>       - 한 모듈에서 다른 모듈의 내부로 제어가 이동하는 경우

##### C. 응집도 
> - 정보 은닉의 확장된 개념 ➡️ 모듈이 독립적인 기능으로 정의되어 있는 정도(= 같은 기능끼리 잘 모아서 모듈을 만들었는가)
> - 응집도가 강할수록 품질이 높음
> - 종류 
>   - 기능적 응집도(7) : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우 
>   - 순차적 응집도(6) : 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우
>   - 교환(통신)적 응집도(5) : 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우
>   - 절차적 응집도(4) : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우
>   - 시간적 응집도(3) : 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우
>   - 논리적 응집도(2) : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우
>   - 우연적 응집도(1) : 모듀 ㄹ내부의 각 구성 요소들이 서로 관련 없는 요소들로 구성된 경우

##### D. 팬인(Fan-In)/팬아웃(Fan-Out)
> - 팬인 : 어떤 모듈을 제어(호출)하는 모듈의 수
> - 팬아웃 : 어떤 모듈에 의해 제어(호출)되는 모듈의 수
> - 팬인과 팬아웃을 분석하면 ➡️ 시스템의 복잡도를 알 수 있음
> - 시스템의 복잡도 최적화 ➡️ 팬인은 높게, 팬아웃은 낮게<br>
> \* 팬인이 높음 : 재사용 측면에서는 설계가 잘됨. 하지만 단일 장애점이 발생할 수 있음
> \* 팬아웃이 높은 : 불필요하게 다른 모듈을 호출하고 있는지 확인할 필요가 있음

##### E. N-S차트(Nassi-Schneiderman Chart)
> - 논리의 기술에 중점을 둔 도형을 이용한 표현 방법으로 박스 다이어그램, Chapin Chart라고 함
> - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조 표현
> - GOTO나 화살표 사용 X
> - 조건 복합되어 있는 곳 처리를 시각적으로 명확히 식별하는데 적합
> - 선택과 반복 구조를 시각적으로 표현
> - 이해 쉽고, 코드 변환 용이
> - 읽기는 쉽지만 작성하기 어려움, 임의로 제어 전이 불가능
> - 총체적인 구조 표현과 인터페이스 표현 어려움
> - 단일 입구과 단일 출구로 표현

#### 나) 공통모듈
> - 여러 프로그램에서 공통적으로 사용할 수 있는 모듈(계산식, 사용자 인증 등)
> - 모듈의 재사용성 확보 및 중복 개발 회피 ➡️ 설계 과정에서 공통 부분 식별 후 명세 작성 필요
> - 공통 모듈 구현 시 다른 개발자들이 명확하게 기능을 알 수 있도록 명세기법을 준수해야 함
##### A. 명세 기법 
>   - 정확성
>   - 명확성 
>   - 완전성
>   - 일관성
>   - 추적성

##### B. 공통모듈의 재사용
> - 비용과 시간을 절약하기 위해 이미 개발된 기능들을 파악, 재구성하여 새로운 시스템, 기능 개발에 적합하도록 최적화시키는 작업
> - 누구나 이해할 수 있고 사용할 수 있도록 사용법 공개
> - 재사용 대상 모듈은 외부 모듈과의 결합도는 낮고 응집도는 높아야 함
> - 규모에 따른 분류
>   - 함수와 객체 : 클래스나 메소드 단위의 소스코드를 재사용
>   - 컴포넌트 : 컴포넌트 수정없이 인터페이스를 통해 통신하는 방식으로 재사용
>   - 애플리케이션 : 공통된 기능을 제공하는 애플리케이션을 공유하는 방식으로 재사용

##### C. 효과적인 모듈 설계 방안
> - 결합도는 줄이고 응집도는 높임 ➡️ 독립성과 재사용성을 높임
> - 모듈의 제어 영역 안에서 그 모듈의 영향 영역을 유지
> - 복잡도와 중복성을 줄이고 일관성 유지
> - 모듈의 기능은 예측 가능해야 함
> - 유지보수가 용이해야 함
> - 하나의 입구와 하나의 출구
> - 효과적인 제어를 위해 모듈 간 계층적 관계를 정의하는 자료를 제시해야 함

### 2) 추상화(Abstraction)


### 3) 단계적 분해(Stepwise Refinement)


### 4) 정보 은닉(Information Hiding)

## 나. 품질 속성
### 1) 시스템 측면


### 2) 비지니스 측면


### 3) 아키텍처 측면

## 다. 설계 과정

# 2. 아키텍처 패턴

# 3. 디자인 패턴

# 4. 객체지향 

# 5. 객체지향 분석 및 설계

# 6. 코드
